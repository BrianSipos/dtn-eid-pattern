<?xml version="1.0" encoding="UTF-8"?>
<?rfc toc="yes"?>
<!DOCTYPE rfc [
 <!ENTITY nbsp    "&#160;">
 <!ENTITY zwsp   "&#8203;">
 <!ENTITY nbhy   "&#8209;">
 <!ENTITY wj     "&#8288;">
]>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="info" consensus="true" docName="draft-ietf-dtn-eid-pattern-05" ipr="trust200902" sortRefs="false" symRefs="true" submissionType="IETF" tocInclude="true" updates="9174,dtn-bpsec-cose" version="3">
  <front>
    <title abbrev="BP EID Patterns">Bundle Protocol Endpoint ID Patterns</title>
    <seriesInfo name="Internet-Draft" value="draft-ietf-dtn-eid-pattern-05"/>
    <author fullname="Brian Sipos" initials="B." surname="Sipos">
      <organization abbrev="JHU/APL">The Johns Hopkins University Applied Physics Laboratory</organization>
      <address>
        <postal>
          <street>11100 Johns Hopkins Rd.</street>
          <city>Laurel</city>
          <region>MD</region>
          <code>20723</code>
          <country>United States of America</country>
        </postal>
        <email>brian.sipos+ietf@gmail.com</email>
      </address>
    </author>
    <date/>
    <area>Transport</area>
    <workgroup>Delay-Tolerant Networking</workgroup>
    <keyword>DTN</keyword>
    <keyword>PKIX</keyword>
    <abstract>
      <t>
This document extends the Bundle Protocol Endpoint ID (EID) concept into an EID Pattern, which is used to categorize any EID as matching a specific pattern or not.
EID Patterns are suitable for expressing configuration, for being used on-the-wire by protocols, and for being easily understandable by a layperson.
EID Patterns include scheme-specific optimizations for expressing set membership and each scheme pattern includes text and binary encoding forms; the pattern for the "ipn" EID scheme being designed to be highly compressible in its binary form.
This document also defines a Public Key Infrastructure Using X.509 (PKIX) Other Name form to contain an EID Pattern and a handling rule to use a pattern to match an EID.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="sec-intro">
      <name>Introduction</name>
      <t>
The Bundle Protocol (BP) Version 7 specification <xref target="RFC9171"/> defines Uniform Resource Identifier (URI) text and Concise Binary Object Representation (CBOR) binary encoding forms of an Endpoint ID (EID). An EID value is used as both a source and a destination for individual Bundles among other uses in BP. In addition to the base protocol, the BP Security (BPSec) specification <xref target="RFC9172"/> uses an EID for security source identity and the TCP Convergence Layer (TCPCL) <xref target="RFC9174"/> uses an EID value for peer identity.
BP Agent implementations have necessarily used methods of defining patterns for matching multiple EIDs in order to configure routing, forwarding, and delivery of Bundles, security policy, and convergence layer policy, but these have not yet been standardized and do not have a concise form suitable for on-the-wire messaging.
      </t>
      <t>
In much the same way that the Classless Inter-domain Routing (CIDR) mechanism <xref target="RFC4632"/> can be used to aggregate a contiguous and bit-aligned block of IP addresses in a concise unit (encoded as text or otherwise), this concept of EID Pattern is used to aggregate a set of EIDs into a single concise unit.
This is valuable because an EID includes both an identifier of the node sending or receiving the Bundle as well as an identifier for the specific service which generated or will process the Bundle.
Any EID Pattern can be used both to aggregate EIDs based on node identifier, service identifier, or both.
      </t>
      <t>
A purely text-based pattern mechanism such as <xref target="W3C-PAT"/> could handle the general case of matching the text form of EIDs (as URIs) but would not be able to achieve the same level of encoding compression and would not be able to express of exact numeric ranges like the scheme-specific mechanism defined in this document.
      </t>
      <t>
The certificate profile and NODE-ID definition of TCPCL <xref target="RFC9174"/> uses the text form of EID to authenticate nodes based on EID.
This document defines a Public Key Infrastructure Using X.509 (PKIX) Other Name Form to contain an EID Pattern and a handling rule to use a pattern to match an EID.
This allows authenticating an individual EID based on an EID Pattern in much the same way as using a "wildcard" certificate to match a DNS name (see <xref section="6.3" target="RFC9525"/>).
      </t>
      <section anchor="sec-goals">
        <name>Goals</name>
        <t>
The text form of an EID Pattern defined in <xref target="sec-eid-pattern"/> is <em>not</em> a URI and is not bound by the character set restrictions imposed for an encoded URI <xref target="RFC3986"/>.
This is much the same as a URI template <xref target="RFC6570"/> is also not itself a URI.
Although some forms of EID Pattern can contain reserved URI characters, it is not guaranteed that any particular EID Pattern will be intrinsically differentiable from an EID.
See <xref target="sec-security"/> for details on handling concerns.
        </t>
        <t>
For the pattern forms defined in <xref target="sec-eid-pattern"/>, the exact-match pattern's text form is identical with its matching EID (with explicitly stated limitations).
This behavior is not required or strictly necessary but is a convenient side effect of the text definitions and makes the EID Pattern a proper superset of EID.
Because of its structure, used to simplify processing, the CBOR form for EID Pattern will never be identical to or a superset of EID.
        </t>
        <t>
One other aspect of this patterning mechanism is that the text form of each scheme-specific pattern is intended to be, in a subjective sense, natural and understandable for the case of a human manually typing patterns into a text document or quick email message; the interpretation of the text pattern needs to "make sense" with minimal training.
        </t>
        <t>
In summary, current and new scheme-specific EID Pattern definitions <bcp14>SHALL</bcp14> specify all of the following:
        </t>
        <ul>
          <li>A logical information model for the scheme-specific pattern.</li>
          <li>Any exceptions or qualifications to the goal of text-form EID being an identity EID Pattern (<em>i.e.</em>, a text EID will act as a pattern unmodified, and that pattern will match only the original EID).</li>
          <li>Logic for matching a specific EID against the information model.</li>
          <li>Logic for performing set operations with the information model (<em>i.e.</em>, pattern unions, intersections, and subset comparisons).</li>
          <li>Both text-form and CBOR-form encodings for those scheme-specific information models.</li>
        </ul>
      </section>
      <section>
        <name>Scope</name>
        <t>
This document defines a logical model of pattern matching BP Endpoint IDs and both text and CBOR encoding forms, as well as PKIX extensions to make use of EID Patterns in a public key certificate (PKC).
        </t>
        <t>
This document does not define a method of disambiguating an EID from an EID Pattern (in either encoded form) without any other context.
Given a pure text or CBOR encoding of an arbitrary value, there needs to be some external context to determine how to interpret it.
        </t>
        <t>
This document defines scheme-specific pattern for the "ipn" URI scheme, as its semantics are well-established, while the other currently registered "dtn" scheme lacks well-defined semantics for the structure of its authority component (which would be necessary for wildcard logic).
        </t>
        <t>
Although the same EID definitions apply to BP Version 6 <xref target="RFC5050"/> this document does not provide any mechanisms of integrating with that protocol.
It is an implementation matter for a BP Agent to use EID Patterns with BP Version 6 and its compressed bundle header encoding (CBHE).
        </t>
      </section>
      <section>
        <name>Use of ABNF</name>
        <t>
This document defines text structure using the Augmented Backus-Naur Form (ABNF) syntax <xref target="RFC5234"/>.
The entire ABNF structure can be extracted from the XML version of this document using the XPath expression:
        </t>
        <sourcecode>'//sourcecode[@type="abnf"]'</sourcecode>
        <t>
The following initial fragment defines the top-level rules of this document's ABNF.
        </t>
        <sourcecode type="abnf">
; Shared wildcard rules
wildcard = "*"
multi-wildcard = "**"

non-zero-decimal = (%x31-39 *DIGIT)
        </sourcecode>
        <t>
The definitions for the rules <tt>pchar</tt> and <tt>scheme</tt> are taken from URI <xref target="RFC3986"/>.
The definition for the rule <tt>digit</tt> is taken from ABNF <xref target="RFC5234"/>.
The definition for the rule <tt>nbr-delim</tt> is taken from BP <xref target="RFC9171"/>.
        </t>
      </section>
      <section>
        <name>Use of CDDL</name>
        <t>
This document defines CBOR structure using the Concise Data Definition Language (CDDL) syntax <xref target="RFC8610"/>.
The entire CDDL structure can be extracted from the XML version of this document using the XPath expression:
        </t>
        <sourcecode>'//sourcecode[@type="cddl"]'</sourcecode>
        <t>
The following initial fragment defines the top-level rules of this document's CDDL, which includes rules needed for validating the example CBOR content.
        </t>
        <sourcecode type="cddl">
start = eid-pattern / embed-eid-pattern
        </sourcecode>
        <t>
The definition for the rule <tt>eid-structure</tt> is taken from BP <xref target="RFC9171"/>.
        </t>
      </section>
      <section anchor="sec-terminology">
        <name>Terminology</name>
        <t>
The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as shown here.
        </t>
        <t>
The terms "Endpoint" and "Endpoint ID" in this document refer to the meanings defined in <xref section="3.1" target="RFC9171"/>.
        </t>
        <t>
Other terms specific to this document are the following.
        </t>
        <dl>
          <dt>Normalize:</dt>
          <dd>
This means to change a pattern value while retaining its meaning, for example enforcing logic like de-duplication, case-insensitivity, or domain constraints.
The internal representation of a pattern is expected to be normalized, even if an encoded value is not (<em>e.g.</em>, human-input text form).
          </dd>
          <dt>Canonicalize:</dt>
          <dd>
This means to choose a specific encoded form of a pattern value without changing the represented logical value, for example using a preferred ordering or a compressed code point.
The text form of encoding has more canonicalization options than the binary form, and human-input text form is expected to not always use canonical choices.
          </dd>
          <dt>Elide:</dt>
          <dd>
This is an encoding choice to not represent both the text and integer form of a scheme in the <xref format="title" target="sec-pattern-arbscheme"/> when it is known by the encoder that all possible decoders of the pattern understand that scheme and are expected to re-constitute the elided form.
          </dd>
        </dl>
      </section>
    </section>
    <section anchor="sec-eid-pattern">
      <name>Patterns for BP Endpoint IDs</name>
      <t>
This document does not define a universal form of EID Pattern, though text forms of EID Patterns do share concepts and rules for wildcard matching (<em>e.g.</em>, <xref target="RFC4592"/>).
Instead, in order to achieve efficiencies in non-text encoding, each EID scheme uses a different form of complex pattern matching.
There are also scheme-independent match-all forms that function without a processor needing scheme-specific logic for all possible schemes.
      </t>
      <t>
An EID Pattern processor <bcp14>MAY</bcp14> normalize the internal representation of a pattern to an equivalent one without keeping track of the original pattern information or encoding.
If an pattern-using application needs to ensure that original encodings are kept, that needs to happen outside of the pattern processor.
See <xref target="sec-envelope"/> for recommendations about this need.
      </t>
      <section anchor="sec-pattern-top">
        <name>Pattern Set and Pattern Items</name>
        <t>
The overall concept of this patterning structure is that one "EID Pattern" can be used to match any combination of EIDs.
This is accomplished by a single pattern being composed of independent pattern items, each with specific rules and syntax.
        </t>
        <t>
The conceptual model of the EID Pattern is as a sequence of pattern items, some of which are general purpose and some with scheme-specific content.
This sequence is ordered in order to make translating between forms deterministic, as each encoding form necessarily has a specific order of items.
        </t>
        <t>
Although the encoding forms are necessarily ordered, the matching logic for an EID Pattern is independent of the order of its items.
An EID pattern <bcp14>SHALL</bcp14> be considered to match an EID if any of its constituent items match the EID.
The sequence is also allowed to be empty, which by that definition will match no EIDs.
        </t>
        <t>
Because matching against an "any-scheme" item (see <xref target="sec-pattern-anyscheme"/>) will necessarily make any scheme-specific patterns redundant, the text and CBOR forms of the EID pattern have a compressed form of any-scheme matching and disallow combining the any-scheme pattern with other items.
        </t>
        <t>
The text form of the EID pattern is the following, which uses the URI reserved character "|" to delimit items in the sequence.
This rule also allows a pattern to be empty, having no items.
Because the delimiter is used between items, an EID pattern with one item has an identical text form to that item.
This correspondence in text form between a single EID and an EID pattern item which matches that single EID <bcp14>SHALL</bcp14> be enforced by any future scheme-specific pattern syntax registered with IANA.
        </t>
        <sourcecode type="abnf">
eid-pattern = any-scheme-item / eid-pattern-set
; The set is allowed to be empty
eid-pattern-set = [ eid-pattern-item *( "|" eid-pattern-item ) ]
eid-pattern-item = scheme-pat-item / any-ssp-item
; Extension point at scheme-pat-item for future scheme-specific rules
scheme-pat-item = ipn-pat-item
        </sourcecode>
        <t>
The CBOR form of the EID pattern is the following, which uses an enveloping array to contain the items.
Because there is otherwise always an outer array, there is no concept of a "bare" scheme-specific pattern item in the CBOR form and no exact correspondence in binary form between a single EID and an EID pattern item which matches that single EID.
        </t>
        <sourcecode type="cddl">
eid-pattern = any-scheme-item / eid-pattern-set
eid-pattern-set = [* eid-pattern-item]
eid-pattern-item = scheme-pat-item / any-ssp-item
; Each pattern still follows eid-structure
scheme-pat-item = $eid-pat-item .within eid-structure
        </sourcecode>
      </section>
      <section anchor="sec-pattern-anyscheme">
        <name>Any-Scheme Pattern Item</name>
        <t>
The simplest pattern item is one which will match any EID of any URI scheme.
Because this necessarily disallows scheme-specific logic, the any-scheme pattern has only its identity with no parameters or conceptual structure.
        </t>
        <t>
When the any-scheme item is present in an EID pattern, it <bcp14>SHALL</bcp14> be the only item in the pattern.
Any other, scheme-specific items would be redundant and unnecessary when combined with the any-scheme item.
        </t>
        <t>
The text form of the any-scheme pattern is the following ABNF which matches only the exact text <tt>*:**</tt>.
As defined in <xref target="sec-pattern-top"/>, when this text form is present it cannot be combined with other items.
        </t>
        <sourcecode type="abnf">
any-scheme-item = wildcard ":" multi-wildcard
        </sourcecode>
        <t>
The CBOR form of the any-scheme pattern is the following CDDL which matches only the exact value <tt>true</tt>.
As defined in <xref target="sec-pattern-top"/>, when this CBOR form is present it occurs outside of an enveloping array and thus cannot be combined with other items.
        </t>
        <sourcecode type="cddl">
any-scheme-item = true
        </sourcecode>
      </section>
      <section anchor="sec-pattern-arbscheme">
        <name>Any-SSP Pattern Item</name>
        <t>
The next most generic pattern item is one which will match any SSP within a specific URI scheme or set of schemes.
This includes schemes known to the EID handler as well as schemes (identified by text or integer value) that need not be understood by the EID handler.
        </t>
        <t>
As a normalization, when an any-SSP item is present in an EID pattern it <bcp14>SHALL</bcp14> be the only item for the associated schemes.
Any other, scheme-specific items would be redundant and unnecessary when combined with the any-SSP item for that same scheme.
        </t>
        <t>
As a normalization, only a single any-SSP item <bcp14>SHALL</bcp14> be used to represent all any-SSP matching in a pattern.
This avoids redundancy in encoded forms and aids in human understanding when all any-SSP matching is combined in one item.
        </t>
        <t>
As a normalization, any schemes identified in any-SSP item <bcp14>SHALL</bcp14> be expanded to include the alternative (text or integer) form of identifier.
This enables the <em>elide</em> logic of the encoded forms and serves to support general purpose matching of either text URI forms of EID (using the text form of scheme identifier) or the CBOR forms of EID (using the integer form of identifier).
        </t>
        <t>
When present, the canonical ordering of pattern items <bcp14>SHALL</bcp14> place the any-SSP item at the front of the list.
        </t>
        <section>
          <name>EID Matching</name>
          <t>
An any-SSP pattern <bcp14>SHALL</bcp14> be considered to match a specific EID when both have the same normalized scheme.
Scheme normalization for text EIDs is to convert to a lower-case alphabetic form in accordance with <xref section="3.1" target="RFC3986"/>.
For schemes which are unknown to the processing entity, the text form of the any-SSP pattern scheme <bcp14>SHALL</bcp14> be used to match text-form EIDs and the integer form of the pattern scheme <bcp14>SHALL</bcp14> be used to match CBOR-form EIDs.
          </t>
          <t>
This means that for entities that cannot process a specific (fictional) private-use scheme with value 65536 and name "example", the following text pattern will guarantee proper handling by any entity:
          </t>
          <sourcecode type="eidpat">
[65536,example]:**
</sourcecode>
        </section>
        <section>
          <name>Pattern Set Logic</name>
          <t>
The parameter for the any-SSP pattern is solely the set of scheme identifiers, so two set logic of the pattern is identical to set logic on those (normalized) identifiers.
This can result in a situation where two pattern processors have different matching logic for the same input pattern if they support different EID schemes and are able to expand elided scheme forms differently.
          </t>
        </section>
        <section anchor="sec-pattern-arbscheme-text">
          <name>Text Form</name>
          <t>
The text form of the any-SSP item is the following ABNF, where the <tt>scheme-id</tt> rule can either be a proper URI <tt>scheme</tt> or a positive integer value (valid values are restricted by the BP scheme registry <xref target="IANA-BP"/>).
          </t>
          <sourcecode type="abnf">
any-ssp-item = scheme-set ":" multi-wildcard
scheme-set = scheme-id / ("[" scheme-id *( "," scheme-id ) "]")
scheme-id = scheme / non-zero-decimal
          </sourcecode>
          <t>
The canonical text encoding of a single scheme in an any-SSP item <bcp14>SHALL</bcp14> omit the square brackets.
The canonical text encoding of the scheme set in an any-SSP item <bcp14>SHALL</bcp14> place integers first, in ascending order, followed by text names, ordered by length first then by the bytewise lexicographical order of their encoded text.
This sorting is identical to the CBOR form in <xref target="sec-pattern-arbscheme-cbor"/>.
          </t>
          <t>
An encoder <bcp14>MAY</bcp14> elide the integer form of a scheme in a text encoding if it is known that all decoders of the pattern will re-constitute the integer form when normalizing the pattern.
It is an implementation matter to determine when to elide during encoding.
          </t>
        </section>
        <section anchor="sec-pattern-arbscheme-cbor">
          <name>CBOR Form</name>
          <t>
The CBOR form of the any-SSP item is the following CDDL.
The first array item conveys no information but because this does not match the <tt>eid-structure</tt> rule, it is guaranteed to be disambiguated with any current or future scheme-specific <tt>$eid-pat-item</tt> socket uses.
          </t>
          <sourcecode type="cddl">
any-ssp-item = [null, + scheme-id]
scheme-id = uint / tstr
          </sourcecode>
          <t>
The canonical CBOR encoding of the scheme set in an any-SSP item <bcp14>SHALL</bcp14> be sorted by the bytewise lexicographic order of their deterministic encodings.
This sorting is the same as the deterministic map key ordering of <xref section="4.2.1" target="RFC8949"/>.
          </t>
          <t>
An encoder <bcp14>MAY</bcp14> elide the text form of a scheme in a CBOR encoding if it is known that all decoders of the pattern will re-constitute the text form when normalizing the pattern.
It is an implementation matter to determine when to elide during encoding.
          </t>
        </section>
      </section>
      <section anchor="sec-pattern-ipn">
        <name>IPN Scheme Pattern Item</name>
        <t>
As defined in <xref section="4.2.5.1.2" target="RFC9171"/> and updated in <xref section="3" target="RFC9758"/>, IPN scheme EIDs have a SSP which is logically divided into three integer numeric components.
Because of this, the pattern for IPN scheme EIDs is based on matching a numeric value or range for each component.
        </t>
        <t>
For the remainder of this document, the term "IPN pattern" is used as shorthand to mean the EID pattern item used for the "ipn" scheme.
        </t>
        <t>
An IPN pattern <bcp14>SHALL</bcp14> logically contain exactly three components corresponding to the IPN scheme EID components of:
        </t>
        <ol>
          <li>Allocator Identifier, with domain 0 to 2^32-1 inclusive</li>
          <li>Node Number, with domain 0 to 2^32-1 inclusive</li>
          <li>Service Number, with domain 0 to 2^64-1 inclusive</li>
        </ol>
        <t>
The conceptual model of the IPN pattern is that each of the components of the SSP can be matched as one of:
        </t>
        <dl>
          <dt>Specific value:</dt>
          <dd>This will match only a single value (as decoded number).</dd>
          <dt>Range:</dt>
          <dd>This will match any value contained in a disjoint set of numeric intervals.</dd>
          <dt>Wildcard:</dt>
          <dd>This will match any valid value, but not the absence of a value.</dd>
        </dl>
        <t>
Within a single component of the IPN pattern, the range intervals <bcp14>SHALL</bcp14> be disjoint and non-contiguous.
Any overlapping or contiguity of intervals within a set can be coalesced into a single covering interval with the same meaning.
The text form of a range can, but <bcp14>SHOULD NOT</bcp14>, contain overlapping or contiguous intervals.
The CBOR form of a range does not allow overlapping or contiguous intervals because of its compressed structure.
Within a single component of the IPN pattern, any range interval that includes values outside the component domain <bcp14>SHALL</bcp14> be reduced to fit the domain.
The decoder for any form of an IPN pattern <bcp14>SHALL</bcp14> normalize all interval sets to satisfy information model requirements.
The decoder for any form of an IPN pattern <bcp14>SHOULD</bcp14> treat the failure of any component of a pattern as a failure to decode the whole pattern.
        </t>
        <section>
          <name>EID Matching</name>
          <t>
An IPN pattern <bcp14>SHALL</bcp14> be considered to match a specific EID when both have the same scheme and each component of the the pattern matches the corresponding logical component of the EID SSP.
If any component doesn't match, the whole pattern does not match.
Each pattern component <bcp14>SHALL</bcp14> be considered to match according to the following rules:
          </t>
          <dl>
            <dt>Specific value:</dt>
            <dd>The pattern component <bcp14>SHALL</bcp14> be compared to the EID component as an exact match of decoded numeric value.</dd>
            <dt>Range:</dt>
            <dd>The pattern component <bcp14>SHALL</bcp14> be considered to match with any EID component value that is contained in any of the finite intervals of the range.</dd>
            <dt>Wildcard:</dt>
            <dd>The pattern component <bcp14>SHALL</bcp14> be considered to match with any EID component.</dd>
          </dl>
          <t>
Because these are dealing with numeric values in an information model, the matching occurs after any encoding-specific normalization (<em>i.e.</em> it's not a text pattern for the text encoding, the matching is performed within the information model of the SSP).
          </t>
        </section>
        <section>
          <name>Pattern Set Logic</name>
          <t>
One benefit of using an EID pattern with an information model of a sequence of numbers or ranges is that performing set logic such as intersection or containment is straightforward.
For set logical behavior, the "specific value" case is treated as a singleton set and the wildcard case is treated as the unbounded-interval.
          </t>
          <t>
Two IPN patterns are equivalent if their matching EID sets are identical.
Two IPN patterns intersect if all of their corresponding components intersect, and the intersection of each component range can be readily computed using multi-interval set logic.
Likewise, one IPN pattern is a subset (or proper subset) of another pattern if all of the components is a subset (or proper subset) of the other's corresponding component.
          </t>
        </section>
        <section>
          <name>Text Form</name>
          <t>
The text form of the IPN pattern conforms to the ABNF in <xref target="fig-pattern-ipn-text"/>, which is a superset of the IPN scheme itself as defined in <xref section="4" target="RFC9758"/> but with a different structure.
Each component is separated by the same character "." as in the IPN URI scheme.
This pattern uses reserved URI characters of "[" and "]" (see <xref section="2.2" target="RFC3986"/>) to indicate the presence of a range set for a component, the character "," to separate the intervals of a range, the character "-" to indicate an interval within the set, and the character "+" to indicate a half-finite interval.
          </t>
          <t>
The enveloping characters "[" and "]" <bcp14>SHALL</bcp14> indicate the presence of a range of possible values for that component.
The logical structure and ABNF below disallows the possibility of nested ranges.
Within each range, the character "," <bcp14>SHALL</bcp14> separate multiple numeric intervals within the range.
The presence of a completely empty interval (<em>e.g.</em>, "[]" or "[,3]") is disallowed by the ABNF below and <bcp14>SHALL</bcp14> be treated as invalid.
If an interval contains a single numeric value it <bcp14>SHALL</bcp14> be treated is a length-one range.
If an interval contains two numeric values separated by a "-" character, the interval <bcp14>SHALL</bcp14> be treated as inclusive of both values.
The lower bound of the interval is expected be on the left side of the "-" separator, but decoders <bcp14>SHALL</bcp14> handle both possible orderings of interval bounds.
If an interval contains a single numeric value followed by the half-finite "+" character it <bcp14>SHALL</bcp14> be treated as having the lower bound of that value and the upper bound as the largest value for that component.
When encoding an interval, if its last included value is the largest value for that component the canonical half-finite form <bcp14>SHALL</bcp14> be used.
          </t>
          <figure anchor="fig-pattern-ipn-text">
            <name>IPN Pattern ABNF Schema</name>
            <sourcecode markers="false" type="abnf">
ipn-pat-item = "ipn:" (ipn-ssp3 / ipn-ssp2)
; Separate allocator and node numbers
ipn-ssp3 = ipn-part-pat nbr-delim ipn-part-pat nbr-delim ipn-part-pat
; First component is the qualified node number
ipn-ssp2 = ("!" / ipn-part-pat) nbr-delim ipn-part-pat
; Each component in the pattern
ipn-part-pat = ipn-decimal / ipn-range / wildcard

; Same normalized form as IPN scheme itself
ipn-decimal = "0" / non-zero-decimal

ipn-range = "[" ipn-interval *( "," ipn-interval ) "]"
ipn-interval = ipn-decimal [ ("-" ipn-decimal) / "+" ]
</sourcecode>
          </figure>
          <t>
When decoding a two-component IPN pattern, the first component <bcp14>SHALL</bcp14> be treated as a fully-qualified node number (FQNN) in accordance with <xref section="3.3.1" target="RFC9758"/> and decomposed into separate allocator and node number components.
When decoding a two-component IPN pattern, the first-component text "!" <bcp14>SHALL</bcp14> be treated as the LocalNode FQNN tuple (0, 2^32 - 1) in accordance with <xref section="3.4.2" target="RFC9758"/>.
When encoding an IPN pattern, the (non-range, non-wildcard) LocalNode FQNN <bcp14>SHOULD</bcp14> be detected and encoded as a two-component pattern using the "!" syntax.
          </t>
          <aside>
            <t>
The FQNN in two-component form has a domain of 0 to 2^64 - 1 inclusive.
            </t>
          </aside>
          <t>
There can be multiple valid ways to decompose an FQNN component containing one or more intervals, and a pattern processor <bcp14>MAY</bcp14> choose any one that results in the same matching logic.
When decoding, a pattern processor does not need to keep track of how many components the original pattern used; the pattern itself always has three components as defined in <xref target="sec-pattern-ipn"/>.
          </t>
          <t>
The canonical text form of an IPN pattern <bcp14>SHALL</bcp14> use three components.
The canonical text form <bcp14>SHALL NOT</bcp14> contain any overlapping or contiguous intervals.
The canonical text form <bcp14>SHALL</bcp14> order all intervals in ascending numeric order.
The canonical text form <bcp14>SHALL</bcp14> encode all intervals with the lower bound before the upper bound.
          </t>
        </section>
        <section>
          <name>CBOR Form</name>
          <t>
The CBOR form of the IPN pattern conforms to the CDDL in <xref target="fig-pattern-ipn-cbor"/>.
Just as in the IPN URI scheme the pattern scheme identifier is 2, the first components of the SSP identify the node and the last component identifies the service.
          </t>
          <t>
Each of the IPN pattern components <bcp14>SHALL</bcp14> be CBOR encoded as follows:
          </t>
          <dl>
            <dt>Specific value:</dt>
            <dd>A number corresponding to the <tt>uint</tt> rule.</dd>
            <dt>Range:</dt>
            <dd>An array item corresponding to the <tt>ipn-range</tt> rule.</dd>
            <dt>Wildcard:</dt>
            <dd>The <tt>true</tt> item.</dd>
          </dl>
          <t>
The wildcard sentinel values have no intrinsic meaning and were simply chosen to be one-octet-encoded special items.
The encoding of ranges is a compressed form in which each logical pair of values in the range array indicates:
          </t>
          <ol>
            <li>The least included value if present in the first pair or the width of the excluded interval (after the previous included interval) for later pairs.</li>
            <li>The width of this included interval, which is omitted if the last interval extends to the largest value for that component (which means it only applies to the last pair).</li>
          </ol>
          <t>
The "width" in these intervals is defined as the difference between the first and last value in the interval, meaning a zero-width interval contains exactly one value.
Another way to interpret the range array is that each number after the first (least) value indicates the width of alternating <em>included</em> and <em>excluded</em> intervals for the range, as depicted in <xref target="fig-diag-ipn-range"/> where the width of the last included interval can be omitted (extending the interval to the whole domain).
          </t>
          <figure anchor="fig-pattern-ipn-cbor">
            <name>IPN Pattern CDDL Schema</name>
            <sourcecode markers="false" type="cddl">
$eid-pat-item /= [
  scheme-num: 2,
  SSP: ipn-ssp
]
ipn-ssp = [
  ; This CDDL representation does not restrict to the
  ; true domain of each component.
  3*3 ipn-part-pat,
]
ipn-part-pat = ipn-val / ipn-range / true

ipn-range = [
  ; least included value
  least: ipn-val,
  * (
    ; width of included interval
    incl: ipn-width
    ; width of excluded interval
    excl: ipn-width,
  ),
  ; Width of last included interval or
  ; an implicit half-finite last included interval
  ? incl: ipn-width
]

ipn-val = uint
ipn-width = uint
</sourcecode>
          </figure>
          <t>
For the compressed form of indicating a half-finite last included interval, a definite-length array head can be used as an early hint because the number of array items will be even when the last interval has an explicit width and odd when it does not.
When encoding a range, if its last included value is the largest value for that component the canonical half-finite form <bcp14>SHALL</bcp14> be used.
          </t>
          <figure anchor="fig-diag-ipn-range">
            <name>IPN Range Encoding</name>
            <artwork align="center"><![CDATA[
      _____(repeated)______
     /                     \
      Include       Exclude       Include
   min       max min       max min       max    component
 <..|.........|...|.........|...|.........|..>  space
    |         |   |         |   |         |
    |<------->|<->|<------->|<->|<------->|
   /   incl     1    excl     1    incl*        encoded
least  width         width         width        fields
]]></artwork>
          </figure>
          <t>
The most simple finite range is a single value, for example the value 10 can be encoded as <tt>[10,0]</tt> (which is a special case because this can also use the non-range specific value encoding).
The most simple disjoint range containing the values 2 and 4 is encoded as <tt>[2,0,0,0]</tt> because each included interval is width zero and each excluded between them is also width zero.
The largest possible range covering the entire 64-bit number space can be encoded as <tt>[0,0xFFFFFFFFFFFFFFFF]</tt> or the more concise canonical form of <tt>[0]</tt> (and even this is a special case because this can also be represented by the wildcard value <tt>true</tt>, but that is a normalization decision not a coding one).
          </t>
        </section>
      </section>
    </section>
    <section anchor="sec-pkix-cert-profile">
      <name>PKIX Certificate Profile Update</name>
      <t>
This document expands upon the PKIX profile of TCPCLv4 <xref target="RFC9174"/> to allow an EID Pattern in any certificate where an Node ID is required or allowed.
      </t>
      <section>
        <name>New Other Name Form</name>
        <t>
This document defines a PKIX Other Name Form identifier, <tt>id-on-bundleEIDPattern</tt> in <xref target="sec-asn1-mod"/>; this identifier can be used as the <tt>type-id</tt> in a Subject Alternative Name (SAN) entry of type <tt>otherName</tt>.
The <tt>BundleEIDPattern</tt> value associated with the <tt>otherName</tt> type-id <tt>id-on-bundleEIDPattern</tt> <bcp14>SHALL</bcp14> be an EID Pattern text form, encoded as an <tt>UTF8String</tt>, with a scheme that is present in the IANA "Bundle Protocol URI Scheme Types" registry <xref target="IANA-BP"/>.
        </t>
        <aside>
          <t>
The other name form is encoded as an <tt>UTF8String</tt> because it is <em>not</em> a URI and does not have all of the character restrictions of a URI.
          </t>
        </aside>
      </section>
      <section>
        <name>New Identifier Type</name>
        <t>
This specification defines an EID-PATTERN-ID of a certificate as being the Subject Alternative Name entry of type <tt>otherName</tt> with a name form of <tt>BundleEIDPattern</tt> and a value limited to an EID Pattern text form.
An entity <bcp14>SHALL</bcp14> ignore any entry of type <tt>otherName</tt> with a name form of <tt>BundleEIDPattern</tt> and a value that is some text other than an EID Pattern.
        </t>
        <t>
The EID-PATTERN-ID is similar to the NODE-ID as defined in <xref section="4.4.1" target="RFC9174"/> but can match many different and distinct Endpoint IDs.
URI matching of an EID-PATTERN-ID <bcp14>SHALL</bcp14> use the scheme-specific EID matching logic defined in this specification.
An EID Pattern scheme can refine this matching logic with rules regarding how Endpoint IDs within that scheme are to be compared with the issued EID-PATTERN-ID.
        </t>
        <t>
As an augmentation of the TCPCL certificate profile in <xref section="4.4.2" target="RFC9174"/>:
Unless prohibited by CA policy, a TCPCL end-entity certificate <bcp14>SHALL</bcp14> contain either a NODE-ID or an EID-PATTERN-ID that authenticates the node ID of the peer.
All other requirements of that certificate profile are unchanged by this document.
        </t>
      </section>
      <section>
        <name>New Name Constraints Logic</name>
        <t>
This document defines a logic for using EID Pattern(s) within the Name Constraints extension of <xref section="4.2.1.10" target="RFC5280"/> for CA certificates.
Because the EID Pattern does not define a general-purpose subset logic, a Name Constraints with an EID Pattern cannot directly constrain subordinate SANs with EID or EID Pattern items so has no effect on path validation (see <xref section="6" target="RFC5280"/>).
It is instead used to constrain the ultimate identity validation (see <xref section="6" target="RFC9525"/> and <xref section="4.4.4" target="RFC9174"/>) for Node IDs specifically and any future validation of EIDs more generally as defined below.
        </t>
        <t>
As an augmentation of the TCPCL peer authentication in <xref section="4.4.4.3" target="RFC9174"/>:
When performing a validation of a Node ID against an end entity certificate with NODE-ID or EID-PATTERN-ID, the validation <bcp14>SHALL</bcp14> also validate the Node ID based on all of the CA certificates in the path which contain a Name Constraints extension itself containing an Other Name Form of <tt>id-on-bundleEIDPattern</tt>.
That match <bcp14>SHALL</bcp14> consider both the permitted and excluded subtrees of the Name Constraints in accordance with <xref section="4.2.1.10" target="RFC5280"/>.
        </t>
        <t>
Due to the nature of matching any possible EID, a Name Constraints extension <bcp14>SHOULD NOT</bcp14> contain an <tt>BundleEIDPattern</tt> with the match-all pattern <tt>*:**</tt> as this serves no purpose.
Including a match-all pattern in the included subtrees does not add any value and including it in the excluded subtrees is functionally the same thing as disallowing the presence of the <tt>id-kp-bundleSecurity</tt> Extended Key Usage.
        </t>
        <t>
When issuing CA or end entity certificates, a CA limited by Name Constraints containing <tt>BundleEIDPattern</tt> values <bcp14>MAY</bcp14> make use of scheme-specific subset logic to determine that the combination of end entity SAN and CA Name Constraints will not validate any possible Node ID and refuse to issue the requested certificate.
For example, a root CA constrained with an included subtree of <tt>ipn:0.*.*</tt> could disallow issuing a subordinate intermediate CA with a constrained included subtree of <tt>ipn:**</tt> because it isn't a proper subset of its parent constraint, or could disallow issuing an end entity certificate with a SAN identity of <tt>ipn:977000.2.3</tt> because it is guaranteed to not pass Node ID validation.
The refusal or not to issue such subordinate certificates does not affect the ultimate validation of the Node ID but does make it less likely for certificates to be used by an end entity which will never succeed at Node ID validation.
        </t>
      </section>
    </section>
    <section anchor="sec-envelope">
      <name>Enveloping Considerations</name>
      <t>
When an EID pattern is enveloped into a data store or protocol data unit, it is important to avoid requiring the processor of that containing context to understand the nuances of EID Pattern syntax.
For the text form of EID Patterns this is straightforward because the encoded text string can simply be handled without concern for its contents.
The use of an EID Pattern as a PKIX Other Name Form in <xref target="sec-pkix-cert-profile"/> makes use of this strategy.
      </t>
      <t>
For the binary form of EID Patterns, when the encoded item is not handled as a simple byte string it is <bcp14>RECOMMENDED</bcp14> to embed the EID Pattern within a CBOR byte string as a single item.
This is formalized by the following CDDL.
      </t>
      <sourcecode markers="false" type="cddl">
embed-eid-pattern = bstr .cbor eid-pattern
      </sourcecode>
      <t>
Embedding in a byte string this way allows BP EID Pattern-unaware processors to handle it without concern for its syntax or validity.
Using a single-item embedding ensures that the number of pattern items contained is still available to decoders in the <tt>eid-pattern</tt> array head.
      </t>
      <t>
A similar recommendation is provided here for enveloping EIDs themselves, which is not discussed in BP <xref target="RFC9171"/> so this document does not formally update that specification.
For the binary form of EIDs, when the encoded item is not handled as a simple byte string it is <bcp14>RECOMMENDED</bcp14> to embed the EID within a CBOR byte string as a single item.
This is formalized by the following CDDL.
      </t>
      <sourcecode markers="false" type="cddl">
embed-eid-structure = bstr .cbor eid-structure
      </sourcecode>
      <t>
Embedding in a byte string this way allows BP EID-unaware processors to handle it without concern for its syntax or validity.
Although this adds some redundancy to the encoding because the <tt>eid-structure</tt> is always a two-element array, it is limited to the single byte of the its array head.
This is also consistent with how the existing Previous Node block-type-specific data content is defined in <xref section="4.4.1" target="RFC9171"/>.
      </t>
    </section>
    <section anchor="sec-security">
      <name>Security Considerations</name>
      <t>
This section separates security considerations into categories based on guidance of BCP 72 <xref target="RFC3552"/>.
      </t>
      <section>
        <name>Denial of Service Possibilities</name>
        <t>
Because EID patterns are expected to be used as external input to a BP Agent, there is the possibility of an encoded value to either be not-well-formed or well-formed but purposefully resource intensive.
Either of these cases can cause resource exhaustion of a BP Agent and thus deny resources to normal data services provided by the Agent.
These considerations are not exclusive to the EID Pattern syntax, and apply just as well to any other external input data.
        </t>
        <t>
An example of a malicious not-well-formed pattern is a CBOR form that contains an array with a definite length that is larger than the actual encoded pattern.
A trivial decoder might attempt to pre-allocate memory based on the array head and exhaust its memory.
A mitigation of this is to have bounds on acceptable lengths/sizes within the CBOR decoder.
        </t>
        <t>
An example with a well-formed pattern is to simply encode a pattern set with thousands or millions of arbitrary, but valid, items.
A decoder could attempt to fully decode this valid pattern but by doing so exhaust its memory.
A similar mitigation here is to bound acceptable sizes above the CBOR layer within the pattern decoding.
        </t>
      </section>
      <section>
        <name>Misinterpretion of Encoded Values</name>
        <t>
It is critical for applications handling EIDs and EID Patterns to positively distinguish between the two based on the context in which the value is being used.
For PKIX Subject Alternative Name this is distinguished by the different Other Name forms.
An EID which is inappropriately interpreted as an EID Pattern could allow an attacker to elevate access depending upon other aspects of the system being accessed.
        </t>
        <t>
CAs which issue certificates containing EID Patterns need to consider the implications of an overly-broad pattern in the same way that current Web PKI CAs manage certificates with wildcard DNS-IDs.
This is discussed for DNS-IDs in <xref section="7.1" target="RFC9525"/>.
        </t>
        <t>
Although the reserved characters "[" and "]" are disallowed within the URI authority and path segments by <xref target="RFC3986"/> there are still URI processors which could be lax about enforcing that restriction and could allow an EID pattern to be decoded in a place where an actual EID is expected.
This could allow unwanted side-effects when the EID is handled by a BP Agent.
        </t>
        <t>
The URI authority part and path segments are percent-encoded text and need to be handled by EID processors as such for both pattern matching and equality comparison.
Additionally, for the IPN scheme there are numeric values that need to be handled as such for pattern matching and comparison.
        </t>
      </section>
      <section>
        <name>Expansion of Elided Any-SSP Schemes</name>
        <t>
The requirements for the any-SSP pattern in <xref target="sec-pattern-arbscheme"/> allow an encoder (which in some cases is expected to be a human) to elide forms of specific scheme identifiers based on knowledge (or assumptions) about decoders of the pattern.
If the knowledge or assumptions are not valid, there is the possibility that 
        </t>
        <t>
For example, given the fully-identified pattern
        </t>
        <sourcecode type="eidpat">
[65536,example]:**
</sourcecode>
        <t>
if this pattern passes through a CBOR encoding which elides the text form, the pattern is logically reduced to
        </t>
        <sourcecode type="eidpat">
[65536]:**
</sourcecode>
        <t>
and any pattern processor which does not know the name "example" for this private use scheme will not be able to match text form EID values.
        </t>
        <t>
As somewhat of a mitigation of this issue, when used as external input to a BP Agent through CBOR encoded pattern the text-elided form will still always be able to properly match CBOR encoded EID values within Bundles themselves.
        </t>
      </section>
    </section>
    <section anchor="sec-iana">
      <name>IANA Considerations</name>
      <t>
This section provides guidance to the Internet Assigned Numbers Authority (IANA) regarding registration of code points in existing registries in accordance with BCP 26 <xref target="RFC8126"/>.
      </t>
      <section anchor="sec-iana-scheme-types">
        <name>Bundle Protocol URI Scheme Types</name>
        <t>
This specification re-uses the "Bundle Protocol URI Scheme Types" registry within the "Bundle Protocol" registry group <xref target="IANA-BP"/> for the CBOR encoding of EID Patterns and adds an informative column "EID Pattern Reference" as in the following table.
        </t>
        <t>
Specifications of new EID Pattern schemes <bcp14>SHALL</bcp14> define all of the required items from <xref target="sec-goals"/> to ensure that pattern behavior is consistent across different schemes.
        </t>
        <table align="center">
          <name>Bundle Protocol URI Scheme Types</name>
          <thead>
            <tr>
              <th>Value</th>
              <th>Description</th>
              <th>...</th>
              <th>EID Pattern Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>2</td>
              <td>ipn</td>
              <td/>
              <td><xref target="sec-pattern-ipn"/> of [This specification]</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sec-iana-pkix-on-oid">
        <name>Object Identifier for PKIX Other Name Forms</name>
        <t>
IANA has created, under the "Structure of Management Information (SMI) Numbers" registry group <xref target="IANA-SMI"/>, a registry titled "SMI Security for PKIX Other Name Forms".
This other name forms table is updated to include a row for containing an Endpoint ID Pattern as in the following table.
        </t>
        <table align="center">
          <name>PKIX Other Name Forms</name>
          <thead>
            <tr>
              <th>Decimal</th>
              <th>Description</th>
              <th>References</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>ON-TBA</td>
              <td><tt>id-on-bundleEIDPattern</tt></td>
              <td>[This specification]</td>
            </tr>
          </tbody>
        </table>
        <t>
The formal structure of the associated other name form is in <xref target="sec-asn1-mod"/>.
The use of this form is defined in <xref target="sec-pkix-cert-profile"/>.
        </t>
      </section>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="IANA-BP" target="https://www.iana.org/assignments/bundle/">
          <front>
            <title>Bundle Protocol</title>
            <author>
              <organization>IANA</organization>
            </author>
          </front>
        </reference>
        <reference anchor="IANA-SMI" target="https://www.iana.org/assignments/smi-numbers/">
          <front>
            <title>Structure of Management Information (SMI) Numbers</title>
            <author>
              <organization>IANA</organization>
            </author>
          </front>
        </reference>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4632.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8610.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8949.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9171.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9174.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9525.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9758.xml"/>
        <reference anchor="X.680" target="https://www.itu.int/rec/T-REC-X.680-201508-I/en">
          <front>
            <title>Information technology -- Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
            <author>
              <organization>ITU-T</organization>
            </author>
            <date month="August" year="2015"/>
          </front>
          <refcontent>ITU-T Recommendation X.680, ISO/IEC 8824-1:2015</refcontent>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4592.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5050.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5912.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6570.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7942.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9172.xml"/>
        <reference anchor="github-ricktaylor-hardy" target="https://github.com/ricktaylor/hardy">
          <front>
            <title>BPv7 DTN server implementation</title>
            <author fullname="Rick Taylor">
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="W3C-PAT" target="https://www.w3.org/2005/Incubator/wcl/matching.html">
          <front>
            <title>URI Pattern Matching for Groups of Resources</title>
            <author>
              <organization>W3C</organization>
            </author>
            <date month="June" year="2006"/>
          </front>
        </reference>
      </references>
    </references>
    <section anchor="sec-asn1-mod">
      <name>ASN.1 Module</name>
      <t>
The following module formally specifies the <tt>BundleEIDPattern</tt> structure and its Other Name form in the syntax of ASN.1 <xref target="X.680"/>.
This specification uses the ASN.1 definitions from PKIX <xref target="RFC5912"/> with the 2002 ASN.1 notation used in that document.
      </t>
      <sourcecode markers="true" type="asn.1">

DTN-EIDPATTERN-2025
  { iso(1) identified-organization(3) dod(6)
    internet(1) security(5) mechanisms(5) pkix(7) id-mod(0)
    id-mod-dtn-eidpattern-2025(MOD-TBA) }

DEFINITIONS IMPLICIT TAGS ::=
BEGIN

IMPORTS
  OTHER-NAME
  FROM PKIX1Implicit-2009 -- [RFC5912]
    { iso(1) identified-organization(3) dod(6) internet(1)
      security(5) mechanisms(5) pkix(7) id-mod(0)
      id-mod-pkix1-implicit-02(59) }

  id-pkix
  FROM PKIX1Explicit-2009 -- [RFC5912]
    { iso(1) identified-organization(3) dod(6) internet(1)
      security(5) mechanisms(5) pkix(7) id-mod(0)
      id-mod-pkix1-explicit-02(51) } ;

id-on OBJECT IDENTIFIER ::= { id-pkix 8 }

DTNOtherNames OTHER-NAME ::= { on-bundleEIDPattern, ... }

-- The otherName definition for Bundle EID Pattern
on-bundleEIDPattern OTHER-NAME ::= {
    BundleEIDPattern IDENTIFIED BY { id-on-bundleEIDPattern }
}

id-on-bundleEIDPattern OBJECT IDENTIFIER ::= { id-on ON-TBA }

-- Encoding allows URI reserved characters
BundleEIDPattern ::= UTF8String

END
</sourcecode>
    </section>
    <section>
      <name>Examples</name>
      <section anchor="sec-ex-pattern-ipn">
        <name>IPN Patterns</name>
        <t>
This section contains examples specific to the IPN pattern of <xref target="sec-pattern-ipn"/>.
        </t>
        <section>
          <name>Exact Match</name>
          <t>
This trivial example matches only one EID (which itself has the same text and CBOR forms)
          </t>
          <sourcecode type="eidpat">
ipn:0.3.4
</sourcecode>
          <t>
which has a CBOR form of:
          </t>
          <sourcecode type="cbor">
[[2, [0, 3, 4]]]
</sourcecode>
        </section>
        <section>
          <name>Wildcards</name>
          <t>
This example matches all service numbers on a single node
          </t>
          <sourcecode type="eidpat">
ipn:0.3.*
</sourcecode>
          <t>
which has a CBOR form of:
          </t>
          <sourcecode type="cbor">
[[2, [0, 3, true]]]
</sourcecode>
          <t>
This example matches all default-authority nodes with the same service number
          </t>
          <sourcecode type="eidpat">
ipn:0.*.4
</sourcecode>
          <t>
which has a CBOR form of:
          </t>
          <sourcecode type="cbor">
[[2, [0, true, 4]]]
</sourcecode>
        </section>
        <section>
          <name>Range Match</name>
          <t>
This example includes a single range over the service numbers <tt>ipn:0.3.0</tt> to <tt>ipn:0.3.19</tt> inclusive as
          </t>
          <sourcecode type="eidpat">
ipn:0.3.[0-19]
</sourcecode>
          <t>
which has a CBOR form of:
          </t>
          <sourcecode type="cbor">
[[2, [0, 3, [0, 19]]]]
</sourcecode>
          <t>
This example includes an offset range over the service numbers <tt>ipn:0.3.10</tt> to <tt>ipn:0.3.19</tt> inclusive as
          </t>
          <sourcecode type="eidpat">
ipn:0.3.[10-19]
</sourcecode>
          <t>
which has a CBOR form of:
          </t>
          <sourcecode type="cbor">
[[2, [0, 3, [10, 9]]]]
</sourcecode>
          <t>
This example includes multiple ranges of service numbers <tt>ipn:0.3.0</tt> to <tt>ipn:0.3.4</tt> and <tt>ipn:0.3.10</tt> to <tt>ipn:0.3.19</tt> inclusive as
          </t>
          <sourcecode type="eidpat">
ipn:0.3.[0-4,10-19]
</sourcecode>
          <t>
which has a CBOR form of:
          </t>
          <sourcecode type="cbor">
[[2, [0, 3, [0, 4, 4, 9]]]]
</sourcecode>
        </section>
        <section>
          <name>Normalization</name>
          <t>
These examples show normalization of specific patterns.
          </t>
          <t>
An overlapping or contiguous pattern such as one of the following
          </t>
          <sourcecode type="eidpat">
ipn:0.3.[0-9,10-19]
ipn:0.3.[0-15,10-19]
ipn:0.3.[10-19,0-9]
</sourcecode>
          <t>
can be normalized to the equivalent pattern
          </t>
          <sourcecode type="eidpat">
ipn:0.3.[0-19]
</sourcecode>
          <t>
An unordered pattern such as
          </t>
          <sourcecode type="eidpat">
ipn:0.3.[10-19,0-4]
</sourcecode>
          <t>
can be normalized to the equivalent pattern
          </t>
          <sourcecode type="eidpat">
ipn:0.3.[0-4,10-19]
</sourcecode>
          <t>
A pattern where a range covers more than the domain of a component, as in
          </t>
          <sourcecode type="eidpat">
ipn:977000.[10000-5000000000].*
</sourcecode>
          <t>
can be normalized to the equivalent (and smaller) pattern
          </t>
          <sourcecode type="eidpat">
ipn:977000.[10000-4294967295].*
</sourcecode>
          <t>
A pattern where a range covers the same values as a wildcard would, as in
          </t>
          <sourcecode type="eidpat">
ipn:977000.[0-4294967295].*
</sourcecode>
          <t>
can be identified and normalized to the equivalent pattern
          </t>
          <sourcecode type="eidpat">
ipn:977000.*.*
</sourcecode>
        </section>
        <section>
          <name>Canonicalization</name>
          <t>
These examples show canonicalization of specific patterns.
          </t>
          <t>
When the FQNN is not a range and indicates the LocalNode as in either of the following
          </t>
          <sourcecode type="eidpat">
ipn:4294967295.[0-10]
ipn:0.4294967295.[0-10]
</sourcecode>
          <t>
it can be canonicalized to the equivalent always-two-component pattern (in text form only)
          </t>
          <sourcecode type="eidpat">
ipn:!.[0-10]
</sourcecode>
          <t>
When an interval has descending bounds such as
          </t>
          <sourcecode type="eidpat">
ipn:0.3.[10-0]
</sourcecode>
          <t>
can be canonicalized to the equivalent pattern
          </t>
          <sourcecode type="eidpat">
ipn:0.3.[0-10]
</sourcecode>
          <t>
When the end of an interval is the largest value of the corresponding component, as in
          </t>
          <sourcecode type="eidpat">
ipn:977000.[10000-4294967295].*
</sourcecode>
          <t>
the last value of the last interval can be canonicalized to the pattern
          </t>
          <sourcecode type="eidpat">
ipn:977000.[10000+].*
</sourcecode>
          <t>
which does not affect the information model but makes the encoded form shorter (and more understandable to a human).
          </t>
        </section>
        <section>
          <name>Disjoint Ranges</name>
          <t>
A single IPN-scheme item is not always able to encode a full desired pattern.
In these cases multiple items will need to be combined, such as in the following text pattern
          </t>
          <sourcecode type="eidpat">
ipn:0.*.*|ipn:977000.*.0
</sourcecode>
          <t>
which has a CBOR form of:
          </t>
          <sourcecode type="cbor">
[
  [2, 0, true, true],
  [2, [977000, true, 0]]
]
</sourcecode>
        </section>
        <section>
          <name>Two-Component Text Form</name>
          <t>
This example includes a range over the FQNN in a two-component form between <tt>ipn:4196183048192100.*</tt> to <tt>ipn:4196183048192500.*</tt> inclusive as as the pattern
          </t>
          <sourcecode type="eidpat">
ipn:[4196183048192100-4196183048192500].*
</sourcecode>
          <t>
which is decomposed into the equivalent three-component pattern
          </t>
          <sourcecode type="eidpat">
ipn:977000.[100-500].*
</sourcecode>
          <t>
which has a CBOR form of:
          </t>
          <sourcecode type="cbor">
[[2, [977000, [100, 400], true]]]
</sourcecode>
          <t>
The next example has a range over the FQNN which spans multiple allocator IDs between <tt>ipn:4196183048192100.*</tt> to <tt>ipn:4196191638126692.*</tt> inclusive as the pattern
          </t>
          <sourcecode type="eidpat">
ipn:[4196183048192100-4196191638126692].*
</sourcecode>
          <t>
which is decomposed into one possible equivalent pattern
          </t>
          <sourcecode type="eidpat">
ipn:977000.[100+].*|ipn:977001.*.*|ipn:977002.[0-100].*
</sourcecode>
          <t>
which has a CBOR form of:
          </t>
          <sourcecode type="cbor">
[
  [2, [977000, [100], true]],
  [2, [977001, true, true]],
  [2, [977002, [0, 100], true]]
]
</sourcecode>
          <t>
As can be seen in that example, because the FQNN interval does not need to neatly align with the per-allocator node number intervals, the general case equivalent pattern will need to include multiple pattern items.
The equivalent pattern also makes use of the wildcard node number in the second item to simplify matching and reduce encoded size when the FQNN interval covers all node numbers within an allocator.
          </t>
        </section>
      </section>
      <section anchor="sec-ex-pattern-multi">
        <name>Combined Patterns</name>
        <t>
This section contains examples of patterns combining items.
        </t>
        <section>
          <name>Match None</name>
          <t>
This trivial example does not match any EID, and this is the preferred way to "match none."
It's text form is empty (so not represented here) and its CBOR form is the empty array
          </t>
          <sourcecode type="cbor">
[]
</sourcecode>
        </section>
        <section>
          <name>Match All</name>
          <t>
This trivial example matches any possible EID, and this is the preferred way to "match all."
It's text form is:
          </t>
          <sourcecode type="eidpat">
*:**
</sourcecode>
          <t>
and its CBOR form is:
          </t>
          <sourcecode type="cbor">
true
</sourcecode>
        </section>
        <section>
          <name>Any-SSP Match</name>
          <t>
These two examples match any ipn-scheme EID, either as fully-identified:
          </t>
          <sourcecode type="eidpat">
[2,ipn]:**
</sourcecode>
          <t>
or integer-elided:
          </t>
          <sourcecode type="eidpat">
ipn:**
</sourcecode>
          <t>
and both have the following CBOR form either as fully-identified:
          </t>
          <sourcecode type="cbor">
[2,"ipn"]
</sourcecode>
          <t>
or text-elided:
          </t>
          <sourcecode type="cbor">
[2]
</sourcecode>
        </section>
        <section>
          <name>Multiple Item Match</name>
          <t>
This example combines items with different schemes together in one pattern, it will match <tt>dtn:**</tt> and <tt>ipn:0.3.4</tt>
It's text form is:
          </t>
          <sourcecode type="eidpat">
dtn:**|ipn:0.3.4
</sourcecode>
          <t>
and its CBOR form is:
          </t>
          <sourcecode type="cbor">
[
  [null, 1],
  [2, [0, 3, 4]]
]
</sourcecode>
        </section>
      </section>
    </section>
    <section numbered="false" removeInRFC="true">
      <name>Implementation Status</name>
      <t>
[NOTE to the RFC Editor: please remove this section before publication, as well as the reference to <xref target="RFC7942"/>, <xref target="github-ricktaylor-hardy"/>.]
      </t>
      <t>
This section records the status of known implementations of the
protocol defined by this specification at the time of posting of
this Internet-Draft, and is based on a proposal described in
<xref target="RFC7942"/>.
The description of implementations in this section is
intended to assist the IETF in its decision processes in progressing
drafts to RFCs. Please note that the listing of any individual
implementation here does not imply endorsement by the IETF.
Furthermore, no effort has been spent to verify the information
presented here that was supplied by IETF contributors. This is not
intended as, and must not be construed to be, a catalog of available
implementations or their features. Readers are advised to note that
other implementations can exist.
      </t>
      <t>
A trial implementation in Rust language of the EID Pattern encoding and decoding and EID matching logic is present as part of the full BP Agent of Hardy <xref target="github-ricktaylor-hardy"/>.
This repository includes unit test vectors for verifying pattern handling.
      </t>
    </section>
    <section anchor="sec-doc-ack" numbered="false">
      <name>Acknowledgments</name>
      <t>
Pattern expressiveness is based on use case examples provided by <contact fullname="Carlo Caini"/> and <contact fullname="Lucien Loiseau"/>.
Prototyping of and validation for the utility of these patterns was performed by <contact fullname="Rick Taylor"/>.
      </t>
    </section>
  </back>
</rfc>
